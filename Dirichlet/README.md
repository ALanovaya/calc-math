# Задача Дирихле для уравнения Пуассона
## Терминология
Введем некоторые обозначения:
- $D$ -- область задания функции, для простоты возьмем единичный квадрат, сформируем дискретную сетку $D_h = \{(x_i, y_j): x_i = ih, y_j = jh, 0\leq i,j \leq (size + 1) \}$, где $h = 1 / (size+ 1)$
- $size$ -- количество узлов по каждой из координат области, то есть размер сетки
- $g(x, y)$ -- функция, к которой аппроксимируем, также ее значениями заполняются границы сетки
- $u(i, j)$ -- аппроксимация $g(x, y)$ в точках $(x_i, y_j)$
- $eps$ -- требуемая точность вычислений, то есть итерации алгоритма продолжаются пока изменения значений $u(i,j)$ не станут меньше данной величины
- $block\_size$ -- размер блока, во всех дальнейших экспериментах по умолчанию равен $64$
Будем считать относительную погрешность вычислений по формуле 
$$(\sum_{\substack{i = 1\\j = 1}}^{size} \frac{|u(i,j) - g(i * h, j * h)|}{|g(i * h, j * h)|} ) / size^2$$

## Начальные значения
Пусть $u(k)$ -- внутренняя сетка с изначально заданными значениями равными $k$. Рассмотрим самую простую функцию -- константу $g(x,y) = c$, где $c \in \mathbb{R} / 0$, возьмем $k = 0.0$, тогда ошибка на сетке $size = 100$ и $eps = 10^{-10}$ будем равна $0.7952$, если попробовать заполнить сетку рандомными значениями из интервала $[-100; 100]$, то ошибка только возрастает 
То есть ошибка зависит от того, чем изначально заполнили внутреннюю сетку, это вполне логично, ведь алгоритм итерационный, и значения на новой итерации зависят от предыдущих, значит и от начальных тоже  
Давайте попробуем заполнять внутреннюю сетку средним граничных значений, тогда хотя бы для константы получим ошибку равную $0.0$, во всех следующих экспериментах будем заполнять внутреннюю сетку также 
## Эксперимент
Все эксперименты проводились на машинке с ОС ```Ubuntu 20.04.5 LTS x86_64``` и процессором ```11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz```
### Эпсилон и оптимальный размер сетки
Рассмотрим линейную функцию $g_1(x,y) = x + y$ и проведем для нее серию экспериментов, ниже представлена таблица, содержащая информацию о времени исполнения и ошибке
|  $size$        |20|40| 80|160|320|-|
|----------------|-|-|--|-|-|--|
|$eps = 10^{-3}$ |$1.9781^{-5}\\ 0.495689$|$1.5299^{-7}\\ 0.53954$|$0.003373\\ 0.372911$| $0.006066\\ 0.454979$| $0.033693\\ 0.513627$| $\text{worktime} \\ \text{error}$|
|$eps = 10^{-6}$ |$7.2999^{-7}\\ 0.495689$|$1.69^{-7}\\ 0.53954$|$0.186611\\ 0.152715$| $0.832236\\ 0.137333$| $16.9186\\ 0.156435$| $\text{worktime} \\ \text{error}$|
|$eps = 10^{-10}$|$5.09^{-7}\\ 0.495689$|$1.74^{-7}\\ 0.53954$|$1.37036\\ 0.154315$| $4.06255\\ 0.134629$| $143.884\\ 0.195885$| $\text{worktime} \\ \text{error}$|
|$eps = 10^{-14}$|$3.13^{-7}\\ 0.495689$|$1.24^{-7}\\ 0.53954$|$1.16836\\ 0.154315$| $7.21609\\ 0.134629$| $236.527\\ 0.195889$| $\text{worktime} \\ \text{error}$|
Из таблицы можно сделать вывод о том, что значение $eps$ на маленьких сетках никакой роли не играет, но вот на больших сетках сильно уменьшает ошибку. Также необходимо отметить тот факт, что при увеличение сетки и фиксированном значение $eps$ ошибка сначала уменьшается до какого-то момента, а потом начинает возрастать, из чего можно сделать вывод о том, что для функции существует некоторое оптимальное разбиение, при котором ошибка минимальна
### Размер блока относительно размера сетки 
Рассмотрим маленькие сетки, так как в таком случае значение $eps$ не влияет на результат, примем $eps = 10^{-3}$, и будем менять размер блока 
|  $size$        |10|20| 50|100|-|
|----------------|-|-|--|-|-|--|
|$block\_size = 64$ |$3.1399^{-7}\\ 0.432952$|$1.07^{-7}\\ 0.495689$|$1.18^{-7}\\ 0.550306$| $0.00287\\ 0.408931$| $\text{worktime} \\ \text{error}$|
|$block\_size = 32$ |$2.7299^{-7}\\ 0.432952$|$1.59^{-7}\\ 0.495689$|$0.000803\\ 0.316408$| $0.003052\\ 0.401423$|  $\text{worktime} \\ \text{error}$|
|$block\_size = 16$|$3.57^{-7}\\ 0.432952$|$0.000410\\ 0.17314$|$0.00076\\ 0.302248$| $0.002315	\\ 0.401421$| $\text{worktime} \\ \text{error}$|
Из результатов таблицы можно сделать вывод о том, что необходимо выбирать $block\_size$ опираясь на размер сетки, это влияет не только на время обработки, но и на ошибку, при правильно подобранном $block\_size$ ошибку можно еще уменьшить 
### Промежуточный итог
Получили, что для функции существует оптимальная сетка, на которой ошибка минимальна, в зависимости от размера сетки необходимо выбирать размер блока, а также тот факт, что при уменьшение $eps$ на больших сетках ошибка уменьшается. Давайте проверим все выше сказанное на других функциях, зафиксируем $eps$ и размер блока.
### Другие функции
Рассмотрим $g_2(x, y) = x^3 + y^3$, $g_3(x, y) = x sin(y) + ycos(x)$, $g_4(x,y) = \frac{1}{\sqrt{x+y+1}}$, $g_5(x, y) = e^{-xy^3}$, $eps = 10^{-14}$
|  $size$        |20|40| 80|160|320|-|
|----------------|-|-|--|-|-|--|
|$g_2$ |$0.005356\\ 0.341215$|$0.0261\\ 1.30774$|$1.13826\\ 0.36421$| $14.2711\\ 0.216401$| $166.89\\ 0.142642$| $\text{worktime} \\ \text{error}$|
|$g_3$ |$0.006177\\ 0.411829$|$0.032673\\ 0.464617$|$1.17468\\ 0.309785$| $15.6448\\ 0.305126$| $175.526\\ 0.309401$| $\text{worktime} \\ \text{error}$|
|$g_4$|$0.0061396\\ 0.0690628$|$0.0268573\\ 0.0633145$|$1.14485\\ 0.0734046$| $14.3352\\ 0.0727716$| $157.413\\ 0.0722573$| $\text{worktime} \\ \text{error}$|
|$g_5$|$0.004954\\ 0.100024$|$0.027758\\ 0.099243$|$1.23593\\ 0.130123$| $15.0103\\ 0.118217$| $185.665\\ 0.113411$| $\text{worktime} \\ \text{error}$|
Данный эксперимент доказывает ранее выдвинутое предположение
